<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>PREMALecture2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<div id="Antivirus scanning"><h1 id="Antivirus scanning" class="header"><a href="#Antivirus scanning">Antivirus scanning</a></h1></div>

<p>
YOu can get a lot of information about a file, just by looking at its <span id="Antivirus scanning-properties"></span><strong id="properties">properties</strong>, like in Windows for example (important to remember for lab 2)
</p>

<p>
A useful first step, but also AV software also relies mostly on signatures or heuristics (like it remembers the patterns, and then tries to identify similartities)
</p>

<p>
Multiple scanners increase the chances to identify known malware (like VirusTotal)
</p>

<p>
There are other ways ot actually google for the issue, like looking at the MD5 hash, or maybe looking for interesting unique strings.
</p>

<div id="Hashing"><h1 id="Hashing" class="header"><a href="#Hashing">Hashing</a></h1></div>

<p>
Hashes are <span id="Hashing-One way Cryptographic Functions"></span><strong id="One way Cryptographic Functions">One way Cryptographic Functions</strong>
</p>

<ul>
<li>
Length is independent of the input size.

<li>
Impossible to calculate the origianl data

<li>
When the function is repreated with same input, hash remains the same

<li>
Digital fingerprinting (also used for file verification), like downloading Arch ISO and checking it with the PGP keys.

<li>
Crypto calculation, creating a unique value

<li>
1-bit change = large difference in value

<li>
MD5 and SHA-1 are most popular

<li>
Black and White List

<li>
Generate, search, share

</ul>
<div id="Strings"><h1 id="Strings" class="header"><a href="#Strings">Strings</a></h1></div>

<p>
First action, just <span id="Strings-look"></span><strong id="look">look</strong> at the file:
</p>
<ul>
<li>
Opening in notepad is not the best idea

<li>
Opening in a hex editor might be better, but still not ideal

<li>
Take a look at <span id="Strings-ASCII"></span><strong id="ASCII">ASCII</strong> strings within a file, with utilities (like BinText)

</ul>
<p>
They are used:
</p>
<ul>
<li>
Identifying sequence of characters

<li>
Print a message

<li>
Connect to URL or domain

<li>
Copy a file

<li>
Registry key

</ul>
<div id="Strings-How does it work?"><h2 id="How does it work?" class="header"><a href="#Strings-How does it work?">How does it work?</a></h2></div>

<p>
ASCII and Unicode strings end with a null terminator
</p>

<p>
ASCII strings use 1 byte per character
</p>

<p>
Unicode ususally uses 2 bytes per character
</p>

<div id="Strings-Searching for Strings"><h2 id="Searching for Strings" class="header"><a href="#Strings-Searching for Strings">Searching for Strings</a></h2></div>

<p>
Is not fool proof
</p>
<ul>
<li>
Do not base all your conclusions on the strings that were found

<li>
May not be used at runtime

<li>
They can be modified (while working)

<li>
Most strings programs only look for 5 or more consecutive ASCII chars

<li>
Always requires Human Interpretation

</ul>
<div id="Packers"><h1 id="Packers" class="header"><a href="#Packers">Packers</a></h1></div>

<p>
The main idea is to obfuscate and pack the malware
</p>

<p>
Obfuscation target:
</p>
<ul>
<li>
Hiding the execution

</ul>
<p>
Packing:
</p>
<ul>
<li>
A subset of obfuscation

<li>
Compressesd and not directly analyzable (like with UPX)

</ul>
<p>
Can protect against Basic Static Techniques
</p>

<p>
Packing goals can be dual:
</p>
<ul>
<li>
Make the malware smaller, obfuscated or both

</ul>
<p>
Packing is like putting 2 EXE's into one. This makes static analysis of a packed file possible, but hard (remember for lab 2)
</p>

<p>
To detect packer, you can use different tools, like <span id="Packers-PEiD"></span><strong id="PEiD">PEiD</strong>, or <span id="Packers-Exeinfo PE"></span><strong id="Exeinfo PE">Exeinfo PE</strong>
</p>

<p>
But you also should be careful, as it might eventually run the application or something
</p>

<div id="PE Headers"><h1 id="PE Headers" class="header"><a href="#PE Headers">PE Headers</a></h1></div>

<p>
PE stands for portable executable (or any other EXE in general)
</p>

<p>
The Windows format for <span id="PE Headers-all"></span><strong id="all">all</strong> executable files
</p>

<p>
PE always has a DOS and an NT Header (for backwards compatibility, and it can be read from the strings
</p>

<p>
The PE header also contains a great number of useful pieces of information for an analyst, like timestamp, linked libraries, API calls, imports, exports
</p>

<p>
PE Header sections:
</p>
<ul>
<li>
Imports - functions that are used from other libraries

<li>
Exports - Functions meant to be used by other programs

<li>
Timestamp - When was the program compiled (last time)

<li>
Sections - Static pieces of data meant to be used during execution

<li>
Subsystem - CLI (CUI) or GUI program

<li>
Resources - Static encoded data such as icons, menu's, strings, logo's

</ul>
<p>
Extensions are not what makes up a file format! Remember Magic Bytes and the fact that you can just rename the file.
</p>

<p>
The imports can tell us a lot about the purpose of the file.
</p>

<p>
One of the most useful tools here would be the Resource Hacker, or Dependency Walker
</p>

<p>
Sometimes if the code is compiled, you will need to decompile it, in order to be able to read the code and maybe the strings themselves.
</p>

</body>
</html>
